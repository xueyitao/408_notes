> # 2.3 同步与互斥

### 2.3.1 进程同步与进程互斥

- **进程同步**

  - **问题**
    - 在多道批处理系统中,多个进程是并发执行的,有时会使用两个及以上的进程来完成一个任务,例如A要写入一个数据,B读取这个数据,这个时候 A 的操作 一定要在B操作的前面,这样的话才能使程序得到正确的结果,但是由于**异步性**的原因,各进程总是相互独立的,以不可预知的速度向前推进. 有可能导致B进程在A进程的前面发生
  - **解决方案**
    - 我们可以使用**进程同步**来解决此类问题
    - 同步也叫做**直接制约关系** ,指的是多个进程完成一个任务,这些进程因为合作,需要在某些位置上协调他们的工作次序而产生的某些制约关系.
  - **显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个进程之间不可以同时运行，他们会相互排斥，必须等待一个进程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的进程（也是一种互斥）！**

- **进程互斥**

  - **问题**

    - 在多道批处理系统中,多个进程是并发执行的,而并发执行会不可避免的使用到系统资源如(摄像头,麦克风),对于这类资源,同一时刻只能分配给一个进程使用因为 你很难想象到 打印机 打印的 第一个字属于 A 进程 而 第二个字属于 B 进程,这显然乱套了,对于这种同一时刻 只能给一个进程使用的计算机资源我们叫做**临界资源**,一方面并发执行的进程需要共享资源,另一方面对于共享资源的访问又必须互斥的进行 **不能同时访问** 这样很显然会导致资源访问的矛盾

  - **解决方案**

    - 这是可以使用进程互斥来解决问题
    - 与进程互斥相关也叫做**间接制约关系**,也就是说 如果A进程正在访问**临界资源**只有当A进程完成访问并释放临界资源后B进程才可以访问临界资源,就是类似于给临界资源加了一把锁.

  - **基本实现原则**

    - 在每个进程中访问临界资源的那段代码被称为**临界区**,而为了保证临界区互斥访问,可以在逻辑上将临界资源访问分为四个部分

      - **进入区:** 如果一个进程想要访问临界资源 会在 进入区 来检查自己是否可以进入临界区,如果可以进入则会设置对应的FLAG 表示自己正在访问临界区,阻止其他进程进入临界区

      - **临界区:**用与访问临界资源的代码,也称为临界段

      - **退出区:** 将正在访问的FLAG清除

      - **剩余区:**其它处理

      - ```C
        while (true){
         	entry section  //进入区 
         	critical section  // 临界区
         	exit section  // 退出区
         	remainder section  // 剩余区
         }
        ```

  - **实现临界互斥必须遵循的原则**

    - **空闲让进:** 如果临界区空闲可以允许一个请求进入临界区
    - **忙则等待:**当已有进程进入临界区,则其他试图进入临界区的进程必须等待
    - **有限等待:**对于请求访问的进程,应保证能在有限时间内进入临界区,防止进程无限等待
    - **让权等待:** 当进程进不去临界区时应立即释放处理机,而不是一直"忙等"

### 2.3.2 实现临界区互斥的基本方法

#### 软件实现方法

1. 单标志法

   - 设置一个公用整型变量turn turn 代表允许进入的进程号,如果turn 设置为0 则代表0号此时可以访问临界区

   - ```c
     进程P0       							进程P1
     while(turn != 0);                  while(turn != 1);
     critical section;                  critical section;
     turn = 1 						   turn = 0 
     remainder section                  remainder section 
     ```

     对于单标志法来说 两个进程必须交替着访问临界区,退出临界区时 将 临界区的使用权  交给另一个进程.但是如果另一个进程再没有使用临界区,则 由于此时turn = 1  那么P0进程 永远进不去临界区,违反了 "**空闲让进**"原则

2. 双标志先检查法

   - 双标志先检查算法  是 使用一个FLAG数组来表示各个进程想要进入临界区的意愿,每次进程访问临界区之前都先检查对方是否想要进入临界区,如果对方想,就等待,否则 将 FLAG数组中 自己的进入临界区的意愿设置为true **"加锁"** 然后再进入临界区

   - ```c
     FLAG[0] = false
     FLAG[1] = false
     进程P0       							进程P1
     while(FLAG[1]);                  while(FLAG[0]);
     FLAG[0] = true                   FLAG[1] = true   //加锁后在进入临界区
     critical section;                critical section;
     FLAG[0] = false					 FLAG[1] = false
     remainder section                remainder section 
     ```

     优点是 可以连续进入临界区,而不需要每次都将进入的权限交给对方,缺点是由于检查 和 加锁的操作是非原子的 也就是说  两个进程可能同时 检测到 对方不想使用临界区,然后两个同时 对临界区加锁然后 访问临界区. 违反"**忙则等待**"原则

3. 双标志后检查法

   - 双标志后检查法 和 双标志先检查法一样的思想,**不过把上锁的操作放在了检查的操作的前面** 所以 由于 上锁和检查 也不是原子性的 所以也可能都无法进入的情况

   - ```
     FLAG[0] = false
     FLAG[1] = false
     进程P0       							进程P1
     FLAG[0] = true                   FLAG[1] = true   //先加锁再进行判断对方是否想要进入
     while(FLAG[1]);                  while(FLAG[0]);
     critical section;                critical section;
     FLAG[0] = false					 FLAG[1] = false
     remainder section                remainder section 
     ```

     可能两个进程同时完成加锁操作 但是 下一步检查对方是否想要进入临界区时 发现对方都会想要进入临界区,然后就会导致两个进程都无法进入临界区. 违反了 "**空闲让进**"原则 由于两个进程一直在不断的检查 也违反了 **"有限等待"**原则

4. Peterson算法

   - 皮特森算法算是结合了 单标志检查法和双标志后检查法 使用了 turn **共享变量** 表达“谦让” 和 FLAG数组来表达意愿，这个算法主动表达了自己想要使用 但是 也愿意让对方先使用，如果谁最后表达了 **谦让**的动作 谁就进行等待

   - ```C
     bool flag[2];  flag[0] = false;  flag[1] = false;
     int turn = 0;     
     
     P0 进程：                        P1 进程：
     flag[0] = true;                 flag[1] = true;
     turn = 1;                       turn = 0;
     while (flag[1] && turn == 1);   while (flag[0] && turn == 0);
     critical section;               critical section;
     flag[0] = false;                flag[1] = false;
     remainder section;              remainder section;
     ```

     Peterson 算法解决了空闲让进、忙则等待、有限等待的问题，但还是没有解决让权等待的问题。也就是说，P1 进程尽管无法进入临界区，并不会释放处理机资源 还是白白的while循环尝试进入临界区。

#### 硬件实现方法

1. 中断屏蔽方法

   - 通过”开/关中断指令“，来实现原子操作。就是让进程在进入临界区之前先**执行关中断指令**”上锁“，保证了此后整个执行过程不会被中断，自然也不会发生进程切换、两个进程同时访问临界资源的情况，在访问完临界区之后，再通过**开中断指令**”解锁“，这样其它进程才有机会访问临界区。
   - 中断屏蔽方法实现进程的互斥操作，但是对于开中断和关中断指令，用户无法执行这种特权指令，故只能用于系统进程，而且中断屏蔽不适合多处理器，中断屏蔽技术只能在一个cpu关中断，而无法保证其他cpu也不会执行相同的访问临界区操作

2. TSL TestandSetLock

   - 在双标志算法中有可能出现同时进入临界区的情况，导致这个的原因是程序执行不是原子性的，而TSL算法是由硬件实现的，可以一气呵成的完成，同时它也做到了像中断屏蔽指令那样，一旦进入临界区，执行过程就无法被中断。

   - 虽然是用硬件完成的，但是可以写一个伪代码

   - ```C
     bool TestAndSet (bool *lock){
         bool old;
         old = *lock;
         *lock = true;
         return old;
     }
     P0:                                        P1:
     while (TestAndSet(&lock));                 while (TestAndSet(&lock));
     critical section;                          critical section;
     lock = false;                              lock = false;
     remainder section;                         remainder section;
     ```

     lock 是全局变量，记录当前临界区是否”上锁“。两个进程会不断检查全局共享变量lock 第一个请求testandset方法的进程会将lock上锁，另外一方面将旧的lock返回，对自己来说，由于返回的是 false，它得以跳过循环进入临界区；而对 P1 进程来说，每次切换到它这里，它在 while 里企图”上锁“和”检查“的时候，都会由于之前全局 lock 已经被置 true 而陷入死循环。

     TSL 指令的方法实现简单，无需严格检查逻辑，也适用于多处理机环境，但是它仍然不满足**”让权等待“**的原则 —— 从伪代码可以看出，P1 在无法如愿进入临界区后仍然可能白白地占用处理机，导致”忙等“。

3. Swap

   - Swap 指令或称 Exchange / XCHG 指令,他的逻辑看起来跟TSL 几乎是一模一样的，都是每次检查的时候将lock的旧值设置为true，然后将lock的值作为当前进程能否访问临界区的一个标志

   - ```
     P0:                             P1:
     bool old = true;                bool old = true;  
     while (old == true)             while (old == true)
     	Swap(&lock,&old)  ;        	    Swap(&lock,&old)  ;  
     critical section;               critical section;
     lock = false;                   lock = false;
     remainder section;              remainder section;
     ```

     Swap  跟TSL 一样 **也不满足让权等待的原则**

### 互斥锁

互斥锁也成为自旋锁是用来解决临界区的上面介绍的 TSL 中断，Swap 指令都是属于互斥锁，如果多个进程共享同一个处理机的话，如果另外一个进程迟迟无法得到锁，就会陷入死循环，其他的进程也无法上处理机只能等待时间片用完，而对于多处理机来说一个线程可以在处理机上循环，也就是所谓的旋转，并不会影响其他的线程的操作，由于自旋的代价其实是小于切换进程的，所以在多处理机下让权等待没有这么严格的要求
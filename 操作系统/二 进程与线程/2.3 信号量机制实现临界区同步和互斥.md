> #  2.3 信号量机制实现临界区同步和互斥

#### 2.3.4 信号量

1. 信号量是一个是一种强大的机制,可以用来解决同步与互斥的问题,**信号量（Semaphore）其实就是一个变量，它可以记录系统中某个资源的数量** 只能通过两个原语wait() 和 signal() 来访问,可以简写为**P()** 和 **V()** 简称**P操作** **V操作**=
   - **注意：**  对系统中同一信号量的访问 由于是使用原语，如果两个进程并发的来访问  这两个对同一信号量的操作的进程 一定会有先后顺序，只可能串行执行。

#### 2.3.4.1 整型信号量

信号量如果单纯是一个整数型的变量，那么就称为整型信号量，在信号量使用整形信号量的情况下，P、V操作就是这样样子

```c#
int S = 1;
wait(int S)               
{                       
    while(S <= 0);//如果当前临界资源没有可用资源 则就会卡在这里
    S = S-1;       
}
signal(int S)
{
    S = S+1;
}
```

同时以两个进程P0 P1来说的话

```C
P0：                    P1:
wait(S)                wait(S)            // 进入区
critical section       critical section   // 临界区
signal(S)              signal(S)          // 退出区 
```

假设P0想要进入临界区,他会在进入临界区之前进行 P操作,进行"检查"和"上锁"的操作.经过检查发现 S = 1 说明有资源访问 则 可以跳过循环,然后执行S = S - 1;把信号量的值变为 0,代表资源的数量已经没有了,这一步相当于上锁操作;这时如果P1 想要访问临界资源,首先需要去进入区 进行 检查上锁两个操作,但是在执行检查的时候发现,S <= 0 则 会发生死循环,直到P0 进程完成临界区资源访问,然后执行V操作释放资源,这是P1就可以进入临界区了.本质上和我们之前的软件没什么区别,但是由于对同一信号量的原语 肯定是串行的,不可能并行,所以也不会出现之前的那种 两个都饥饿或者两个都进入的情况.但是如果P0操作再一个时间片内没有完成对临界资源的访问的话,P1 也只能白白的循环,违反了 "**让权等待**"的原则.于是在此基础上出现了记录型信号量.

#### 2.3.4.1 记录型信号量

记录型信号量与整型信号量不同的地方在于它使用一个带链表的数据结构L 

L指向的是一个等待队列,如果一个进程的访问临界资源的需求无法被满足时,干脆不让它陷入循环,而是直接把他阻塞,这样进程被唤醒之前无法占用处理机.在占用临界资源的进程释放后,才考虑把阻塞队列唤醒.

记录型信号量的结构如下:

```
typedef struct {
    int value
    sturct process *L  // 阻塞队列
} semaphore
```

同时记录型信号量的P、V操作也和整型不一样:

```C
wait (semaphore S){
    S.value--
    if(S.value < 0){
        block(S.L)   //当资源数不够的时候 将该队列阻塞
    }
}
signal(semaphore S){
    S.value++
    if(S.value <= 0){
        wakeup(S.L)   // 每释放一个资源时判断是否有阻塞队列,将它唤醒直接运行
    }
}
```

1. 这里**value** 变量代表的时可用资源数当它大于0 时代表存在可用资源,当小于0 时 代表不存在可用资源
2. 不管 是否资源足够,都会让value - 1 **代表申请到了资源**或者 有进程想要申请资源
3. 每次释放一个资源后的value 都会 + 1,如果+1 后仍小于等于 0 代表阻塞队列里有申请过资源的进程,则立即将他访问临界资源

用四个进程来模拟一下信号量的工作过程

```C
PO:            P1              P2           P3
wait(S)        wait(S)         wait(S)      wait(S)
临界区          临界区          临界区        临界区
signal(S)      signal(S)       signal(S)    signal(S)
```

假设计算机中有两台可用的打印机 A 和 B（也就是说，value = 2），有四个进程需要用到打印机资源。

假定一开始时 P0占用处理机,这是 value -1 = 1 则代表申请到了临界资源.然后P0进入临界区工作,等到P0 的时间片用完,P1 开始占用处理机,这时 value - 1= 0 代表P1申请到了临界资源.然后P1 进入临界区工作,直到P1的时间片用完,然后P2占用处理机,这时 value - 1 = -1 < 0 代表无可用的临界资源,然后直接将P2挂起进入阻塞队列,P2直接**主动**终止处理机的占用,接下来到P3 这时value - 1  = -2 < 0 则代表无可用资源,然后P3 执行和P2 一样的操作,将自己阻塞,停止占用处理机.

这时轮到P0运行,这次P0执行结束,则在退出区释放临界资源,value + 1 变成 -1 <= 0 代表阻塞队列里有进程等着用资源,然后直接将P2 唤醒并直接进入临界区工作,这时P2 执行结束后,释放临界资源 value + 1 = 0 <=0 代表阻塞队列里还有进程需要用资源,这时将P3 唤醒 直接进入临界区工作,P3 执行完后释放临界资源,这时value +1 =  1 代表阻塞队列中无阻塞的进程,这时继续轮转执行P4.P4执行完后释放资源 这时value + 1  = 2   value 的值 1 变回最初的 2 ，代表占用的资源已经全数归还。

**注:一个进程释放资源后 将阻塞队列里的进程唤醒后执行的操作 并不是 直接 从阻塞态转为执行态而是 阻塞态->就绪态->执行态**

记录型信号量符合了"**让权等待**"=>原则不会有进程白白的使用循环占用处理机.

> 记录型信号量明显优于整型信号量，所以在提到 PV 操作的时候，一般默认指的都是记录型信号量。